/* 
   drvgcode.cpp : This file is part of pstoedit
   simple backend for CNC g code format.
   Contributed / Copyright 2008 by: Lawrence Glaister VE7IT 

   Copyright (C) 1993 - 2013 Wolfgang Glunz, wglunz35_AT_pstoedit.net
   (for the skeleton and the rest of pstoedit)

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/

#include "drvgcode.h"

#include I_stdio
#include I_string_h
#include I_iostream
#include <time.h>
#include <version.h>

drvGCODE::derivedConstructor(drvGCODE):
constructBase
{
// driver specific initializations
	if (options->intensity.value != "") {
		options->intensity.value = "M3 S" + options->intensity.value + "\n";
	} else {
		options->intensity.value = "M3\n";
	}
	if (options->traversal.value == "") {
		options->traversal.value = "6000";
	}

}

drvGCODE::~drvGCODE()
{
	options=0;
}

void drvGCODE::open_page()
{
	if (!options->noheader) {
	//date and time of convertion
	time_t kz = time(NULL);;
	struct tm *ozt = localtime(&kz);
	static char sdate[30];
	strftime(sdate, (size_t) 30, "%c", ozt);

  	outf << "; Generated by pstoedit " << version << " from " << inFileName.value() << " at " << sdate << "\n";
	outf << "; gcode output module by Lawrence Glaister VE7IT\n";
	outf << "M106		; fan on\n";
	outf << "M84		; disable steppers until next move\n";
	outf << "G21            ; set units to millimeters\n";
	outf << "G90            ; set absolute positioning\n";
	outf << "G92 X0 Y0	; zero x and y axes\n";
	}
}

void drvGCODE::close_page()
{
	if (!options->nofooter) {
	outf << "M5         ; laser off\n";
	outf << "G28 F200   ; home all axes\n";
	outf << "G90        ; use absolute coordinates\n";
	outf << "G0 Y558 F6000	; retract gantry for (un)loading\n";
	outf << "M84        ; power down all stepper motors\n";
	outf << "M107       ; fan off\n";
	}
}

void drvGCODE::show_path()
{
	Point currentPoint(0.0f, 0.0f);	
	const Point firstPoint = pathElement(0).getPoint(0);
	const float scale = 1.0f / 72.0f * 25.4f; // pstoedit works natively at 72dpi but RepRaps like millimeters	

	for (unsigned int n = 0; n < numberOfElementsInPath(); n++) {
		const basedrawingelement & elem = pathElement(n);

		switch (elem.getType()) {
		case moveto:{
				const Point & p = elem.getPoint(0);
				outf << "\nM5\n";
				outf << "G0 X" << p.x_ * scale << " Y" << p.y_ * scale << " F" << options->traversal.value << "\n";
				outf << "\n" << options->intensity.value; // fire the laser
				currentPoint = p;
			}
			break;
		case lineto:{
				const Point & p = elem.getPoint(0);
				outf << "G1 X" << p.x_ * scale << " Y" << p.y_ * scale << " F" << options->speed.value << "\n";
				currentPoint = p;
			}
			break;
		case closepath:
				outf << "G1 X" << firstPoint.x_ * scale << " Y" << firstPoint.y_ * scale << " F" << options->speed.value << "\n";
			break;

		case curveto:{
			const Point & cp1 = elem.getPoint(0);
			const Point & cp2 = elem.getPoint(1);
			const Point & ep  = elem.getPoint(2);
			// curve is approximated with a variable number or linear segments.
			// fitpoints should be somewhere between 5 and 50 for reasonable page size plots
			// we compute distance between current point and endpoint and use that to help
			// pick the number of segments to use.
			const float dist = (float) pythagoras((float)(ep.x_ - currentPoint.x_),(float)(ep.y_ - currentPoint.y_)); 
			unsigned int fitpoints = (unsigned int)(dist / 10.0);
			if ( fitpoints < 5 ) fitpoints = 5;
			if ( fitpoints > 50 ) fitpoints = 50;

			for (unsigned int s = 1; s < fitpoints; s++) {
				const float t = 1.0f * s / (fitpoints - 1);
				const Point pt = PointOnBezier(t, currentPoint, cp1, cp2, ep);
				outf << "G1 X" << pt.x_ * scale << " Y" << pt.y_ * scale << " F" << options->speed.value << "\n";
			}
			currentPoint = ep;

			}
			break;
		default:
			errf << "\t\tFatal: unexpected case in drvgcode " << endl;
			abort();
			break;
		}
	}
}


static DriverDescriptionT < drvGCODE > D_gcode("gcode", "RepRap gcode format", 
												 "See also:  \\URL{http://reprap.org/wiki/G-code} ","gcode", false,	// if backend supports subpathes
												   // if subpathes are supported, the backend must deal with
												   // sequences of the following form
												   // moveto (start of subpath)
												   // lineto (a line segment)
												   // lineto 
												   // moveto (start of a new subpath)
												   // lineto (a line segment)
												   // lineto 
												   //
												   // If this argument is set to false each subpath is drawn 
												   // individually which might not necessarily represent
												   // the original drawing.
												   true,	// if backend supports curves
												   false,	// if backend supports elements with fill and edges
												   false,	// if backend supports text
												   DriverDescription::noimage,	// no support for PNG file images
												   DriverDescription::normalopen, false,	// if format supports multiple pages in one file
												   false /*clipping */ );
 
