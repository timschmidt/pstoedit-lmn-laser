/* 
   drvgcode.cpp : This file is part of pstoedit
   simple backend for CNC g code format.
   Contributed / Copyright 2008 by: Lawrence Glaister VE7IT 

   Copyright (C) 1993 - 2013 Wolfgang Glunz, wglunz35_AT_pstoedit.net
   (for the skeleton and the rest of pstoedit)

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/

#include "drvgcode.h"

#include I_stdio
#include I_string_h
#include I_iostream
#include <time.h>
#include <version.h>

drvGCODE::derivedConstructor(drvGCODE):
constructBase
{
// driver specific initializations
	
}

drvGCODE::~drvGCODE()
{
	options=0;
}

void drvGCODE::open_page()
{
	//date and time of convertion
	time_t kz = time(NULL);;
	struct tm *ozt = localtime(&kz);
	static char sdate[30];
	strftime(sdate, (size_t) 30, "%c", ozt);

  	outf << "; Generated by pstoedit " << version << " from " << inFileName.value() << " at " << sdate << "\n";
	outf << "; gcode output module by Lawrence Glaister VE7IT\n";
	outf << "G21            ; set units to millimeters\n";
	outf << "G90            ; set absolute positioning\n";
	outf << "G28		; home all axes\n";
	outf << "G0 Z78.0	; raise Z axis to material cutting height: 84mm - material thickness\n";

}

void drvGCODE::close_page()
{
	outf << "M5         ; laser off\n";
	outf << "M84        ; power down all stepper motors\n";
}

void drvGCODE::show_path()
{
	Point currentPoint(0.0f, 0.0f);	
	const Point firstPoint = pathElement(0).getPoint(0);

	for (unsigned int n = 0; n < numberOfElementsInPath(); n++) {
		const basedrawingelement & elem = pathElement(n);

		switch (elem.getType()) {
		case moveto:{
				const Point & p = elem.getPoint(0);
				outf << "\nM5\n";
				outf << "G0 X" << p.x_ << " Y" << p.y_ << " F6000\n";
				outf << "\nM3\n";
				currentPoint = p;
			}
			break;
		case lineto:{
				const Point & p = elem.getPoint(0);
				outf << "G1 X" << p.x_ << " Y" << p.y_ << " F200\n";
				currentPoint = p;
			}
			break;
		case closepath:
				outf << "G1 X" << firstPoint.x_ << " Y" << firstPoint.y_ << " F200\n";
			break;

		case curveto:{
			const Point & cp1 = elem.getPoint(0);
			const Point & cp2 = elem.getPoint(1);
			const Point & ep  = elem.getPoint(2);
			// curve is approximated with a variable number or linear segments.
			// fitpoints should be somewhere between 5 and 50 for reasonable page size plots
			// we compute distance between current point and endpoint and use that to help
			// pick the number of segments to use.
			const float dist = (float) pythagoras((float)(ep.x_ - currentPoint.x_),(float)(ep.y_ - currentPoint.y_)); 
			unsigned int fitpoints = (unsigned int)(dist / 10.0);
			if ( fitpoints < 5 ) fitpoints = 5;
			if ( fitpoints > 50 ) fitpoints = 50;

			for (unsigned int s = 1; s < fitpoints; s++) {
				const float t = 1.0f * s / (fitpoints - 1);
				const Point pt = PointOnBezier(t, currentPoint, cp1, cp2, ep);
				outf << "G1 X" << pt.x_ << " Y" << pt.y_ << " F200\n";
			}
			currentPoint = ep;

			}
			break;
		default:
			errf << "\t\tFatal: unexpected case in drvgcode " << endl;
			abort();
			break;
		}
	}
}


static DriverDescriptionT < drvGCODE > D_gcode("gcode", "RepRap gcode format", 
												 "See also:  \\URL{http://reprap.org/wiki/G-code} ","gcode", false,	// if backend supports subpathes
												   // if subpathes are supported, the backend must deal with
												   // sequences of the following form
												   // moveto (start of subpath)
												   // lineto (a line segment)
												   // lineto 
												   // moveto (start of a new subpath)
												   // lineto (a line segment)
												   // lineto 
												   //
												   // If this argument is set to false each subpath is drawn 
												   // individually which might not necessarily represent
												   // the original drawing.
												   true,	// if backend supports curves
												   false,	// if backend supports elements with fill and edges
												   false,	// if backend supports text
												   DriverDescription::noimage,	// no support for PNG file images
												   DriverDescription::normalopen, false,	// if format supports multiple pages in one file
												   false /*clipping */ );
 
